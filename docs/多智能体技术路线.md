📝 项目技术路线与架构说明 (SRL-Agent)
项目名称： 基于 SRL 理论的学术写作辅导平台 项目代号： “SRL-Agent” 核心架构： Dify 单一 Chatflow（混合输出模式）

1. 核心目标
本系统旨在模拟一个多智能体（RPA - 角色扮演智能体）团队，为用户的学术写作提供“多元视角”的反馈，并能（PSA - 问题解决智能体）提供具体的写作帮助。

2. 关键架构决策
我们采用单一 Dify Chatflow 架构，以利用 Dify 原生的“记忆 (Memory)”功能来自动管理共享的对话上下文。这避免了前端手动管理上下文的复杂性。

此 Chatflow 采用“混合输出模式”，在一个 API 响应中先后提供两种不同类型的数据，以平衡 RPA 输出的稳定性 和 PSA 输出的速度。

3. Dify Chatflow 详细流程
Start 节点：

自动接收 {{sys.query}} 和 Dify 自动管理的对话历史。

LLM 1 (RPA_Agent) 节点：

记忆 (Memory)： 开启。以读取完整的对话历史。

核心任务： 模拟“SRL助教”、“同桌”、“学术专家”三者的对话，并生成下一步行动摘要。

输出模式： 结构化输出 (JSON)。

JSON Schema：

JSON

{
  "discussion_script": [],
  "requires_solution": true,
  "summary_for_solver": "..."
}
目的： 牺牲 LLM 1 的流式输出，换取 100% 稳定、可解析的 JSON，为前端 UI 渲染提供坚实基础。

Answer 1 (RPA_Answer) 节点：

流式输出： 关闭 (OFF)。

回答内容： 使用**“标签包装”**来封装 LLM 1 的 JSON 输出：

[RPA:START]{{structured_output}}[RPA:END]
目的： 为前端解析器提供一个清晰、明确的非流式数据块。

Code 节点 (Extract_Summary)：

输入： rpa_json = {{structured_output}} (Dify 已自动将其转为 dict)。

逻辑：

从 rpa_json 字典中提取 requires_solution 和 summary_for_solver。

如果 requires_solution 为 False，则 return {'task_summary': 'SKIP_PSA'}。

否则，return {'task_summary': ...}。

If/Else 节点 (Should_Run_PSA)：

条件： {{code_output.task_summary}} 不等于 SKIP_PSA。

LLM 2 (PSA_Agent) 节点： (位于 If/Else 的 True 分支)

记忆 (Memory)： 开启。以读取完整的对话历史（包括 RPA_Agent 刚刚的输出）。

Prompt： 结合 {{sys.conversation_history}} 和 {{code_output.task_summary}} 来执行具体的写作任务。

Answer 2 (PSA_Answer) 节点： (位于 If/Else 的 True 分支)

流式输出： 开启 (ON)。

回答内容： 使用**“标签包装”**来标识流式答案的开始：

[PSA:START]{{llm_output.text}}
目的： [PSA:START] 标签通知前端“JSON 已结束，后续所有内容均为纯文本流”。

4. API 合约与前端渲染责任
前端只需调用一个 Dify API。前端的核心任务是实现一个**“双模态流解析器”**。

API 响应： 前端将收到一个单一的、持久的流式连接。

解析器逻辑：

阶段 1：缓冲与 JSON 解析

前端持续缓冲收到的数据流 chunk。

等待，直到 buffer 同时包含 [RPA:START] 和 [RPA:END] 标签。

一旦匹配，立即提取两个标签之间的完整 JSON 字符串。

安全地 JSON.parse() 这个字符串。

使用 discussion_script 的内容一次性渲染 RPA 的“剧本”UI。

阶段 2：流式文本解析

继续缓冲后续数据。

等待，直到在流中检测到 [PSA:START] 标签。

一旦匹配，丢弃该标签，并切换渲染模式。

此后，将所有新收到的 chunk 实时、逐字地流式渲染到 PSA 的 UI 区域，直到 API 连接关闭。